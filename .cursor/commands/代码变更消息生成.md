# 代码变更消息生成

分析当前工作区的代码变更，按功能模块智能分组，生成中文提交消息（支持单次或多次提交）。

## 交互方式规范

参考指令交互规范：[指令交互规范](../../rules/指令交互规范.md)

**所有选项都必须按照以下方式呈现和选择：**

1. **列出选项**：将所有可选项按照从上到下的顺序排列，并加上序号（0, 1, 2...）
2. **用户输入**：用户只需输入序号即可选择对应的选项
3. **选项格式**：每个选项显示为：`[序号]. 选项描述`
4. **统一应用**：所有交互选项都遵循此规范

## 核心理念

### 安全限制（重要！）

- **禁止执行提交**：本命令仅生成提交消息，**严禁执行** `git add`、`git commit`、`git push` 等任何会修改Git仓库状态的命令
- **只读分析**：仅使用 `git status`、`git diff`、`git log` 等只读命令分析工作区状态
- **自动执行只读命令**：所有只读的Git命令（`git status`、`git diff`、`git diff --stat`、`git diff --cached`、`git log`、`git branch` 等）**必须自动执行**，无需人工确认或介入
- **禁用分页器**：所有 `git diff` 和 `git log` 命令必须使用 `--no-pager` 选项（即 `git --no-pager diff`），避免分页器交互，确保一次性输出所有内容
- **手动执行**：生成的Git命令需要用户手动复制执行

### 智能分组原则

- **功能关联**：将实现同一功能的修改归为一组
- **模块划分**：按代码模块/目录结构进行初步分组
- **依赖关系**：考虑代码依赖关系，确保每次提交都是完整的功能单元
- **最小化原则**：每次提交应该尽量小且聚焦，便于代码审查和回滚

### 提交信息规范

遵循 Conventional Commits 规范，使用以下前缀：

| 前缀 | 说明 | 示例 |
|------|------|------|
| `feat` | 新功能 | feat: 添加用户登录功能 |
| `fix` | 修复Bug | fix: 修复登录失败的问题 |
| `refactor` | 重构代码 | refactor: 重构用户认证模块 |
| `docs` | 文档更新 | docs: 更新API文档 |
| `style` | 代码格式 | style: 格式化代码缩进 |
| `chore` | 构建/工具 | chore: 更新依赖版本 |
| `test` | 测试相关 | test: 添加单元测试 |
| `perf` | 性能优化 | perf: 优化查询性能 |

## 功能选项

在开始生成提交消息时，必须按照以下顺序列出功能选项，并加上序号：

### 0. 多次提交（智能分组）

按功能模块智能分组，生成多个独立提交消息。

**适用场景**：
- 修改涉及多个功能模块
- 希望保持提交历史清晰
- 便于代码审查和问题追踪

**执行流程**：
1. 分析所有修改文件
2. 识别功能模块和代码关联
3. 智能分组，生成多个提交消息
4. 为每个提交生成中文日志

### 1. 自定义N次提交

用户指定提交次数，AI重新分组生成计划。

**适用场景**：
- 对提交次数有特定要求
- 需要手动控制分组粒度
- 团队有特定的提交规范

**执行流程**：
1. 询问用户期望的提交次数N
2. 分析所有修改文件
3. 按N次要求重新分组
4. 为每个提交生成中文日志

### 2. 一次提交

所有修改合并为一次提交消息。

**适用场景**：
- 修改量较小
- 所有修改属于同一功能
- 快速提交不需要拆分

**执行流程**：
1. 分析所有修改文件
2. 汇总所有修改内容
3. 生成单次提交的中文日志

## 使用流程

### 重要：自动执行原则

**所有只读Git命令必须自动执行，无需人工介入或确认。**

#### 分页器问题与解决方案

**问题**：默认情况下，`git diff` 和 `git log` 等命令会使用分页器（通常是 `less` 或 `more`）来显示输出。当输出内容较长时，需要用户：
- 按空格键或回车键翻页
- 按 `q` 键退出分页器

这会导致命令无法自动完成，需要人工交互。

**解决方案**：所有可能触发分页器的命令必须使用 `--no-pager` 选项：

```bash
# ❌ 错误：会触发分页器，需要人工交互
git diff

# ✅ 正确：禁用分页器，一次性输出所有内容
git --no-pager diff

# ✅ 正确：也可以使用管道输出
git diff | cat
```

**推荐使用 `git --no-pager diff`**，因为：
- 更明确地表达意图
- 不依赖外部命令（cat）
- 适用于所有平台

当用户选择提交方式后，AI必须：
1. **立即自动执行**所有必要的只读命令（`git status`、`git --no-pager diff` 等）
2. **不得等待**用户确认或批准
3. **不得询问**是否执行某个命令
4. **自动遍历**所有修改文件，执行 `git --no-pager diff <文件路径>` 获取详细差异（禁用分页器）
5. **自动处理**子模块差异（`git --no-pager diff --submodule=short`，禁用分页器）

**禁止的行为**：
- ❌ 询问用户"是否执行 git diff？"
- ❌ 等待用户确认后再执行命令
- ❌ 只执行部分命令，等待用户输入
- ❌ 要求用户手动执行 git diff 命令
- ❌ 使用 `git diff` 而不加 `--no-pager`，导致分页器交互（需要人工按空格/回车翻页或按 q 退出）

**正确的行为**：
- ✅ 用户选择提交方式后，立即自动执行所有分析命令
- ✅ 并行执行多个只读命令以提高效率
- ✅ 自动读取所有修改文件的diff内容
- ✅ 自动分析并生成提交消息
- ✅ **所有 git diff 命令必须使用 `--no-pager` 选项**，避免分页器交互（如 less/more），确保一次性输出所有内容

### 第一步：显示功能菜单

**必须立即显示**功能菜单选项，**无需等待或预先读取任何文档**，直接按照以下格式显示选项供用户选择：

```
请选择提交方式：
0. 多次提交（智能分组） - 按功能模块智能分组，生成多个独立提交消息
1. 自定义N次提交 - 指定提交次数，AI重新分组生成计划
2. 一次提交 - 所有修改合并为一次提交消息

请输入序号（0-2）：
```

用户输入序号后，根据用户选择执行对应的功能。

如果用户输入无效序号，提示重新输入。

### 第二步：分析工作区状态（自动执行，无需人工介入）

**重要**：以下所有只读命令必须**自动执行**，无需等待用户确认或人工介入。

执行以下只读命令分析工作区：

1. **获取修改状态**（自动执行）：
   ```bash
   git status
   git branch --show-current  # 获取当前分支名
   ```
   - 识别已修改（modified）的文件
   - 识别新增（untracked）的文件
   - 识别已删除（deleted）的文件
   - 识别已暂存（staged）的文件
   - 获取当前分支名称

2. **获取修改详情**（自动执行）：
   ```bash
   git --no-pager diff --stat       # 修改统计（先执行，获取文件列表，禁用分页器）
   git --no-pager diff              # 未暂存的修改（自动执行，禁用分页器，一次性输出所有内容）
   git --no-pager diff --cached     # 已暂存的修改（自动执行，禁用分页器，一次性输出所有内容）
   ```
   - 对于每个修改的文件，自动执行 `git --no-pager diff <文件路径>` 获取详细差异（禁用分页器）
   - 对于子模块，自动执行 `git --no-pager diff --submodule=short <子模块路径>` 获取子模块差异（禁用分页器）
   - **所有 diff 命令必须使用 `--no-pager` 选项**，避免分页器（less/more）交互，确保一次性输出所有内容，无需人工按空格/回车翻页或按 q 退出
   - **所有 diff 命令必须自动执行，不得等待用户确认**

3. **分析修改内容**（自动分析）：
   - 自动读取每个修改文件的diff内容
   - 自动分析代码变更的类型（新增/修改/删除）
   - 自动识别修改的功能模块
   - 自动识别代码关联关系

### 第三步：智能分组（选项0和1）

根据以下规则对修改进行分组：

1. **目录结构分析**：
   - 相同目录下的修改倾向于归为一组
   - 识别领域层/协议层/UI层等模块边界

2. **代码关联分析**：
   - 头文件和对应的实现文件归为一组
   - 相互引用的文件归为一组
   - 实现同一功能的文件归为一组

3. **修改类型分析**：
   - 重构类修改单独分组
   - Bug修复单独分组
   - 新功能开发单独分组
   - 配置文件修改单独分组

4. **依赖关系分析**：
   - 确保每次提交包含完整的功能单元
   - 避免出现编译错误或运行时错误

### 第四步：生成提交消息

为每个分组生成提交消息，格式如下：

```markdown
## 代码变更消息

### 提交 1/N：{提交标题}

**类型**：{feat/fix/refactor/docs/style/chore/test/perf}

**文件列表**：
- `path/to/file1.cpp`
- `path/to/file2.h`
- `path/to/file3.qml`

**修改摘要**：
{简要描述本次提交的修改内容}

**提交信息**：
```
{type}: {简短描述}

{详细说明，可多行}

- 修改点1
- 修改点2
- 修改点3
```

**Git命令**（手动执行）：
```bash
git add path/to/file1.cpp path/to/file2.h path/to/file3.qml
git commit -m "{type}: {简短描述}

{详细说明}

- 修改点1
- 修改点2
- 修改点3"
```

---

### 提交 2/N：{提交标题}
...
```

### 第五步：显示完整计划

显示完整的提交消息，包括：

1. **计划概览**：
   ```
   === 代码变更消息 ===

   分支：{当前分支名}
   修改文件数：{总文件数}
   计划提交次数：{N次}

   ⚠️ 安全提示：以下命令需要手动复制执行，本工具不会自动执行任何提交操作。
   ```

2. **详细提交计划**：按上述格式显示每个提交的详细信息

3. **执行顺序建议**：
   ```
   建议执行顺序：
   1. 先执行提交1的命令
   2. 验证提交1无误后，执行提交2的命令
   3. 依次执行后续提交
   4. 所有提交完成后，执行 git push
   ```

### 第六步：完成并返回菜单

显示完成提示，询问用户是否需要其他操作：

```
✓ 代码变更消息生成完成！

请手动复制上述Git命令执行提交。

⚠️ 提醒：
- 本工具仅生成消息，不会自动执行任何提交
- 执行前请仔细检查提交内容
- 建议逐个提交并验证

是否需要重新生成？
0. 是，重新选择提交方式
1. 否，结束

请输入序号（0-1）：
```

## 示例

### 示例1：多次提交（智能分组）

```
用户：/代码变更消息生成

AI：请选择提交方式：
    0. 多次提交（智能分组） - 按功能模块智能分组，生成多个独立提交消息
    1. 自定义N次提交 - 指定提交次数，AI重新分组生成计划
    2. 一次提交 - 所有修改合并为一次提交消息

    请输入序号（0-2）：

用户：0

AI：正在分析工作区修改...
    （自动执行 git status、git --no-pager diff 等只读命令，禁用分页器，无需人工确认）

    检测到以下修改：
    - 已修改：10 个文件
    - 新增：2 个文件
    - 删除：0 个文件

    正在智能分组...

    === 代码变更消息 ===

    分支：feature/new-feature
    修改文件数：12
    计划提交次数：4

    ⚠️ 安全提示：以下命令需要手动复制执行，本工具不会自动执行任何提交操作。

    ---

    ### 提交 1/4：重构LED灯配置管理

    **类型**：refactor

    **文件列表**：
    - `src/Domain/Light/DeviceLedsManager.cpp`

    **修改摘要**：
    重构旗语灯配置，使用数据驱动设计（FlagLedConfig结构体），优化ledNumberAdjust函数

    **提交信息**：
    ```
    refactor: 重构LED灯配置管理，优化旗语灯配置逻辑

    - 使用数据驱动方式管理旗语灯配置，支持W13/W17/S09/W18等设备
    - 优化ledNumberAdjust函数，使用lambda函数简化数组调整逻辑
    - 移除硬编码的设备类型判断，提高代码可维护性
    ```

    **Git命令**（手动执行）：
    ```bash
    git add src/Domain/Light/DeviceLedsManager.cpp
    git commit -m "refactor: 重构LED灯配置管理，优化旗语灯配置逻辑

    - 使用数据驱动方式管理旗语灯配置，支持W13/W17/S09/W18等设备
    - 优化ledNumberAdjust函数，使用lambda函数简化数组调整逻辑
    - 移除硬编码的设备类型判断，提高代码可维护性"
    ```

    ---

    ### 提交 2/4：修复本地参数组配置问题
    ...

    ### 提交 3/4：添加方向盘127固件新参数
    ...

    ### 提交 4/4：更新QML界面支持V2版本参数
    ...

    ---

    建议执行顺序：
    1. 先执行提交1的命令
    2. 验证提交1无误后，执行提交2的命令
    3. 依次执行后续提交
    4. 所有提交完成后，执行 git push

    ✓ 代码变更消息生成完成！

    请手动复制上述Git命令执行提交。

    是否需要重新生成？
    0. 是，重新选择提交方式
    1. 否，结束

    请输入序号（0-1）：
```

### 示例2：自定义N次提交

```
用户：/代码变更消息生成

AI：请选择提交方式：
    0. 多次提交（智能分组） - 按功能模块智能分组，生成多个独立提交消息
    1. 自定义N次提交 - 指定提交次数，AI重新分组生成计划
    2. 一次提交 - 所有修改合并为一次提交消息

    请输入序号（0-2）：

用户：1

AI：请输入期望的提交次数（1-10）：

用户：3

AI：正在分析工作区修改...
    （自动执行 git status、git --no-pager diff 等只读命令，禁用分页器，无需人工确认）

    检测到以下修改：
    - 已修改：10 个文件
    - 新增：2 个文件

    正在按3次提交重新分组...

    === 代码变更消息 ===

    分支：feature/new-feature
    修改文件数：12
    计划提交次数：3

    ⚠️ 安全提示：以下命令需要手动复制执行，本工具不会自动执行任何提交操作。

    ---

    ### 提交 1/3：后端功能优化和参数定义
    ...

    ### 提交 2/3：配置文件更新
    ...

    ### 提交 3/3：界面适配
    ...
```

### 示例3：一次提交

```
用户：/代码变更消息生成

AI：请选择提交方式：
    0. 多次提交（智能分组） - 按功能模块智能分组，生成多个独立提交消息
    1. 自定义N次提交 - 指定提交次数，AI重新分组生成计划
    2. 一次提交 - 所有修改合并为一次提交消息

    请输入序号（0-2）：

用户：2

AI：正在分析工作区修改...
    （自动执行 git status、git --no-pager diff 等只读命令，禁用分页器，无需人工确认）

    检测到以下修改：
    - 已修改：10 个文件
    - 新增：2 个文件

    === 代码变更消息 ===

    分支：feature/new-feature
    修改文件数：12
    计划提交次数：1

    ⚠️ 安全提示：以下命令需要手动复制执行，本工具不会自动执行任何提交操作。

    ---

    ### 提交 1/1：适配方向盘127固件，支持V2版本参数

    **类型**：feat

    **文件列表**：
    - `src/Domain/Light/DeviceLedsManager.cpp`
    - `src/Domain/Light/LedCustomLocalParameterStrategyManager.cc`
    - `src/Domain/LocalParameter/LocalParameterGroup.cc`
    - `src/Domain/Steering/SteeringDynamicInformation.h`
    - `src/Domain/Steering/SteeringProgram.cc`
    - `src/Gui/File/SteeringLocalParametersDefault.json`
    - `src/Gui/Steering/EditSteeringButtonColorItem.qml`
    - `src/Gui/Steering/SteeringPageButtonLightConfigPane.qml`
    - `src/Gui/Steering/WheelW17ButtonTest_v2.qml`
    - `src/Gui/Steering/WheelW18ButtonTest_v2.qml`

    **修改摘要**：
    适配方向盘127固件版本，添加V2版本参数支持，包括旋钮灯参数、待机模式V2参数等

    **提交信息**：
    ```
    feat: 适配方向盘127固件，支持V2版本参数

    - 重构LED灯配置管理，使用数据驱动设计
    - 修复本地参数组配置导出/导入问题
    - 添加旋钮灯相关参数（newKnobGroupBrightness等）
    - 添加V2版本待机模式参数
    - 更新默认配置文件，添加V2版本参数
    - 更新QML界面，支持V2版本参数和版本判断
    ```

    **Git命令**（手动执行）：
    ```bash
    git add .
    git commit -m "feat: 适配方向盘127固件，支持V2版本参数

    - 重构LED灯配置管理，使用数据驱动设计
    - 修复本地参数组配置导出/导入问题
    - 添加旋钮灯相关参数（newKnobGroupBrightness等）
    - 添加V2版本待机模式参数
    - 更新默认配置文件，添加V2版本参数
    - 更新QML界面，支持V2版本参数和版本判断"
    ```

    ---

    ✓ 代码变更消息生成完成！
```

## 重要规范

### 安全规范（必须遵守！）

1. **禁止执行的命令**：
   - `git add` - 禁止执行
   - `git commit` - 禁止执行
   - `git push` - 禁止执行
   - `git reset` - 禁止执行
   - `git checkout` - 禁止执行（除非是只读查看）
   - `git merge` - 禁止执行
   - `git rebase` - 禁止执行
   - 任何会修改Git仓库状态的命令 - 禁止执行

2. **允许执行的命令**（必须自动执行，无需人工确认）：
   - `git status` - 查看状态（自动执行）
   - `git --no-pager diff` - 查看差异（自动执行，禁用分页器，一次性输出所有内容）
   - `git --no-pager diff --stat` - 查看统计（自动执行，禁用分页器）
   - `git --no-pager diff --cached` - 查看暂存区差异（自动执行，禁用分页器）
   - `git --no-pager diff <文件路径>` - 查看特定文件差异（自动执行，禁用分页器，遍历所有修改文件）
   - `git --no-pager diff --submodule=short` - 查看子模块差异（自动执行，禁用分页器）
   - `git --no-pager log` - 查看日志（自动执行，禁用分页器，如需要）
   - `git branch` - 查看分支（自动执行）
   - `git branch --show-current` - 获取当前分支名（自动执行）
   - `git remote -v` - 查看远程仓库（自动执行）
   
   **重要**：
   - 以上所有只读命令在执行时**不得等待用户确认**，必须自动执行完成
   - **所有可能触发分页器的命令（如 `git diff`、`git log`）必须使用 `--no-pager` 选项**，确保一次性输出所有内容，避免需要人工按空格/回车翻页或按 q 退出

3. **输出规范**：
   - 生成的Git命令必须以代码块形式展示
   - 明确标注"手动执行"
   - 每次显示安全提示

### 交互规范

- **菜单优先**：必须首先立即显示功能菜单
- **按需执行**：用户选择选项后再执行分析
- **自动执行只读命令**：用户选择提交方式后，所有只读Git命令（`git status`、`git diff` 等）必须**自动执行**，无需等待用户确认或人工介入
- **禁用分页器**：所有可能触发分页器的命令（如 `git diff`、`git log`）必须使用 `--no-pager` 选项，确保一次性输出所有内容，避免需要人工交互
- **完整展示**：显示完整的提交消息，不省略
- **循环交互**：完成后询问是否需要重新生成

### 提交信息规范

- **使用中文**：提交信息的描述部分使用中文
- **前缀规范**：使用标准的Conventional Commits前缀
- **简洁明了**：标题行不超过50个字符
- **详细说明**：正文部分详细列出修改点

## 项目特定说明

本指令是项目 pit-house 专用指令，仅适用于当前项目。

**与 git提交 的区别**：
- **git提交**：执行 Git 提交操作，直接修改仓库状态
- **代码变更消息生成**：仅分析变更并生成提交消息，不执行提交，需用户手动复制执行

**与通用指令的区别**：
- 本项目使用 pit-house 作为项目名称，指令存储在 `.cursor/commands/pit-house/` 下
- 当调用 `/代码变更消息生成` 时，优先使用本指令

**使用场景**：
- pit-house 项目的代码变更消息生成
- 需要按功能模块智能分组生成提交消息时

## 完成操作

执行完一个完整的选项后：

1. **显示完成提示**：确认消息已生成
2. **安全提醒**：提醒用户手动执行命令
3. **返回菜单**：询问是否需要重新生成
